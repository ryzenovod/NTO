# Давайте разберемся, как устроен маршрут курьера.

# Он должен доставить n посылок по n адресам.
# Каждый раз он едет из офиса (адрес 0) к клиенту (например, по адресу A), а потом возвращается в офис. 
# Расстояние за такой рейс: путь(0 -> A) + путь(A -> 0). Так как дороги двусторонние, это просто 2 * путь(0 -> A).
# Так он делает для n-1 посылок.
# Для последней посылки (скажем, по адресу B), он едет из офиса к клиенту и остается там. Расстояние за этот рейс: путь(0 -> B).
# Итого, общая дистанция — это сумма расстояний для всех n-1 "двойных" поездок и одной "одинарной".

# Чтобы минимизировать общую дистанцию, нам нужно сделать так, чтобы "одинарная" поездка (которая экономит нам путь назад) 
# была самой длинной из всех возможных. То есть, в последнюю очередь нужно ехать по самому дальнему от офиса адресу.

# Отсюда вытекает план:

# Найти кратчайшие пути от офиса (точка 0) до всех n адресов клиентов. Для этого идеально подходит алгоритм Дейкстры.
# Просуммировать все эти кратчайшие пути.
# Найти самый длинный из этих путей.
# Общая дистанция будет равна: (Сумма всех путей) * 2 - (Самый длинный путь).
# Если хотя бы до одного адреса невозможно добраться, то и все посылки доставить не получится.

# Для реализации алгоритма Дейкстры нам понадобится "очередь с приоритетом"
# (или "куча"). В Python она есть в модуле heapq.
import heapq

# --- Шаг 1: Чтение входных данных и создание графа ---

# Считываем n (число адресов) и m (число дорог).
n, m = map(int, input().split())

# Город — это граф. Представим его в виде "списка смежности".
# Это список, где для каждого адреса (индекса) хранится список его соседей
# и длин дорог до них.
# Адреса нумеруются от 0 до n, поэтому нам нужен список размером n + 1.
graph = [[] for _ in range(n + 1)]

# В цикле m раз считываем информацию о дорогах.
for _ in range(m):
    # a, b - адреса, l - длина дороги между ними.
    a, b, l = map(int, input().split())
    # Дороги двусторонние, поэтому добавляем информацию в обе стороны:
    # из a можно попасть в b, а из b - в a.
    graph[a].append((b, l)) # к списку соседей для 'a' добавляем (сосед 'b', длина 'l')
    graph[b].append((a, l)) # и наоборот

# --- Шаг 2: Алгоритм Дейкстры для поиска кратчайших путей от офиса (точки 0) ---

# Создаем список для хранения кратчайших расстояний от офиса до каждого адреса.
# Вначале мы не знаем ни одного пути, поэтому считаем их бесконечно большими.
# Расстояние до самого себя (офиса) равно 0.
distances = [float('inf')] * (n + 1)
distances[0] = 0

# Создаем очередь с приоритетом. В ней будут лежать пары (расстояние, адрес).
# Очередь автоматически будет выдавать нам адрес с наименьшим расстоянием.
# Начинаем с офиса: расстояние 0, адрес 0.
pq = [(0, 0)] # (distance, vertex)

# Основной цикл алгоритма. Работает, пока в очереди есть адреса для рассмотрения.
while pq:
    # Достаем из очереди адрес с наименьшим известным расстоянием.
    dist, u = heapq.heappop(pq)

    # Если мы нашли более короткий путь к этому адресу 'u' ранее,
    # то эту запись в очереди можно просто проигнорировать.
    if dist > distances[u]:
        continue

    # Теперь посмотрим на всех соседей 'v' текущего адреса 'u'.
    for v, weight in graph[u]:
        # Если путь через 'u' к соседу 'v' короче, чем известный нам путь к 'v'...
        if distances[u] + weight < distances[v]:
            # ...то обновляем кратчайший путь до 'v'.
            distances[v] = distances[u] + weight
            # И добавляем соседа 'v' в очередь, чтобы рассмотреть его в будущем.
            heapq.heappush(pq, (distances[v], v))

# --- Шаг 3: Расчет итогового расстояния ---

# Нам нужны расстояния только до адресов клиентов (с 1 по n).
# Создадим для них отдельный список.
client_distances = distances[1:]

# Переменные для расчета:
total_sum = 0     # Сумма всех кратчайших путей
max_dist = 0      # Самый длинный из кратчайших путей
possible = True   # Флаг, который показывает, возможна ли доставка

# Проходим по всем путям до клиентов.
for d in client_distances:
    # Если расстояние до какого-то клиента - бесконечность, значит, до него не добраться.
    if d == float('inf'):
        possible = False # Доставка невозможна
        break            # Прерываем цикл

    # Если добраться можно, то:
    total_sum += d          # Увеличиваем общую сумму путей
    if d > max_dist:        # Если этот путь самый длинный из тех, что мы видели,
        max_dist = d        # запоминаем его.

# --- Шаг 4: Вывод результата ---

if possible:
    # Если доставка возможна, считаем ответ по нашей формуле.
    result = total_sum * 2 - max_dist
    print(result)
else:
    # Если хотя бы до одного клиента не доехать - выводим -1.
    print(-1)