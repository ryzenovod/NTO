#Основная идея решения (жадный алгоритм)
#Представьте, что вы — диспетчер такси. У вас есть несколько пассажиров и несколько машин. 
#Кому нужно отдать машину в первую очередь, чтобы в итоге все уехали и вы потратили как можно меньше денег?

# Самый сложный клиент — тот, кому нужно ехать дальше всех. У него меньше всего вариантов, 
# так как ему подойдут только такси с большим запасом хода. 
# Если мы не сможем найти машину для него, то задача уже нерешаема.

#Поэтому самая разумная стратегия — это "жадный" подход:

#Сначала находим машину для пассажира, которому нужно ехать дальше всех.
#Из всех подходящих для него машин выбираем самую дешёвую (с минимальной ценой за километр).
#Затем берём следующего по дальности пассажира и ищем для него самую дешёвую машину из оставшихся.
#Повторяем так для всех пассажиров, от самых "дальних" до самых "близких".
#Если на каком-то шаге мы не можем найти подходящую машину для очередного пассажира, значит, решить задачу невозможно.

# --- Шаг 1: Чтение входных данных ---

# Считываем первую строку: n - количество пассажиров, m - количество такси.
# map(int, input().split()) читает строку, делит по пробелам и превращает части в целые числа.
n, m = map(int, input().split())

# Считываем вторую строку: n расстояний, которые нужно проехать пассажирам.
# Всё это помещаем в список (массив) с названием distances.
distances = list(map(int, input().split()))

# Создаем пустой список для хранения информации о такси.
taxis = []
# В цикле m раз считываем информацию о каждом такси.
for _ in range(m):
    # L - максимальная дальность, p - цена за километр.
    L, p = map(int, input().split())
    # Добавляем информацию о такси в виде списка [дальность, цена] в наш общий список.
    taxis.append([L, p])


# --- Шаг 2: Подготовка данных ---

# Сортируем расстояния пассажиров по убыванию (от самого длинного к самому короткому).
# Это ключ к нашему "жадному" алгоритму: сначала разбираемся с самыми требовательными пассажирами.
distances.sort(reverse=True)

# Создаем список, чтобы отмечать, какие такси уже заняты.
# Изначально все такси свободны (значение False).
# Длина списка равна количеству такси (m).
used_taxis = [False] * m


# --- Шаг 3: Жадное распределение пассажиров по такси ---

# Переменная для хранения общей стоимости всех поездок. Вначале она равна 0.
total_cost = 0

# Основной цикл: проходим по каждому пассажиру, начиная с того, кому ехать дальше всех.
for d in distances:
    # Для каждого пассажира мы будем искать лучшее такси.
    # best_taxi_index будет хранить номер (индекс) лучшего найденного такси.
    # Изначально ставим -1, что означает "такси пока не найдено".
    best_taxi_index = -1
    # min_price будет хранить цену самого дешевого из подходящих такси.
    # Изначально ставим очень большое число (бесконечность), чтобы цена любого реального такси была меньше.
    min_price = float('inf')

    # Теперь ищем подходящее такси. Просматриваем все такси по очереди.
    for i in range(m):
        # Проверяем два условия:
        # 1. Это такси еще не занято (used_taxis[i] is False)?
        # 2. Это такси может проехать нужное расстояние (taxis[i][0] >= d)?
        if not used_taxis[i] and taxis[i][0] >= d:
            # Если оба условия выполнены, такси нам подходит.
            # Теперь проверяем, является ли оно самым дешевым из всех подходящих, что мы уже видели.
            if taxis[i][1] < min_price:
                # Если да, то это наш новый лучший кандидат!
                # Запоминаем его цену и его номер (индекс).
                min_price = taxis[i][1]
                best_taxi_index = i

    # После того как мы проверили все такси для текущего пассажира:
    # Проверяем, смогли ли мы найти для него машину.
    if best_taxi_index == -1:
        # Если best_taxi_index так и остался -1, значит, ни одно свободное такси
        # не может проехать нужное расстояние. Решить задачу невозможно.
        total_cost = -1  # Устанавливаем итоговую стоимость в -1.
        break            # И немедленно выходим из цикла, так как дальше искать нет смысла.
    else:
        # Если мы нашли подходящее такси (индекс не -1):
        # 1. Рассчитываем стоимость поездки: расстояние * цена за км.
        cost_of_trip = d * min_price
        # 2. Добавляем эту стоимость к общей.
        total_cost += cost_of_trip
        # 3. Отмечаем, что это такси теперь занято, чтобы другие пассажиры не могли его взять.
        used_taxis[best_taxi_index] = True


# --- Шаг 4: Вывод результата ---

# Печатаем итоговую общую стоимость.
# Если мы вышли из цикла из-за невозможности найти такси, здесь будет напечатано -1.
# Если все пассажиры были успешно распределены, здесь будет минимальная суммарная стоимость.
print(total_cost)