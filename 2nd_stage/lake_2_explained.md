# Подробное объяснение решения "Великая озёрная регата 2"

## 1. Ввод данных (строки 7-59)

```python
data = sys.stdin.read().strip().split()
it = iter(data)
```

Читаем все данные сразу и разбиваем на токены. Используем итератор для удобного чтения.

**Что читаем:**
- Точка A (xA, yA, zA) - начальная позиция камеры
- Точка B (xB, yB, zB) - конечная позиция камеры  
- Скорость v - скорость движения камеры
- Направление камеры (lx, ly, lz) - куда смотрит камера
- N лодок, каждая с координатами вершины (xb, yb, hb)
- M гор, каждая с параметрами (xm, ym, hm, rm)

---

## 2. Построение базиса камеры (строки 61-92)

**Зачем это нужно?** Камера имеет свою систему координат. Нам нужно переводить точки из глобальной системы координат в систему координат камеры, чтобы проверить, попадает ли объект в кадр.

### 2.1. Вектор "вперёд" (f) - строки 63-72

```python
len_l = math.sqrt(lx*lx + ly*ly + lz*lz)
fx = lx / len_l
fy = ly / len_l
fz = lz / len_l
```

**Что делаем:** Нормируем вектор направления камеры `l`, получаем единичный вектор `f = (fx, fy, fz)`.

**Геометрический смысл:** Это ось Z камеры - направление, куда смотрит камера.

### 2.2. Вектор "вправо" (r) - строки 74-87

```python
if abs(lx) + abs(ly) > EPS:
    r0x = -ly
    r0y = lx
    r0z = 0.0
else:
    r0x = 1.0
    r0y = 0.0
    r0z = 0.0
```

**Что делаем:** Строим горизонтальную ось камеры, лежащую в плоскости z=0.

**Геометрический смысл:** 
- Если проекция `l` на плоскость XY не нулевая, берём перпендикуляр: `r0 = (-ly, lx, 0)`
- Это векторное произведение `(0,0,1) × (lx, ly, lz)` в проекции на XY
- Если `l` вертикален, берём `(1, 0, 0)` как горизонтальную ось

Затем нормируем: `r = r0 / |r0|`

### 2.3. Вектор "вверх" (u) - строки 89-92

```python
ux = fy*rz - fz*ry
uy = fz*rx - fx*rz
uz = fx*ry - fy*rx
```

**Что делаем:** Вычисляем векторное произведение `u = f × r`.

**Геометрический смысл:** Это вертикальная ось камеры. Формула векторного произведения:
```
u = f × r = |i    j    k  |
           |fx   fy   fz |
           |rx   ry   rz |
```

**Результат:** Получаем ортонормированный базис камеры (f, r, u):
- `f` - вперёд (ось Z камеры)
- `r` - вправо (ось X камеры)  
- `u` - вверх (ось Y камеры)

---

## 3. Предобработка гор (строки 94-104)

```python
alpha = (rm * rm) / (hm * hm)
rm2 = rm * rm
```

**Зачем:** Предвычисляем константы, которые не зависят от позиции камеры.

**Геометрический смысл:**
- Конус горы: радиус на высоте z равен `r(z) = rm * (1 - z/hm)`
- `alpha = (rm/hm)²` - коэффициент для квадратичного члена в формуле проверки пересечения
- `rm2` - квадрат радиуса для быстрой проверки расстояний

---

## 4. Проверка попадания в кадр (строки 108-125)

### Функция `in_camera_fov_at`

**Задача:** Проверить, попадает ли вершина лодки в поле зрения камеры (FOV 90°).

```python
dx = xb - Cx
dy = yb - Cy
dz = hb - Cz
```

**Что делаем:** Вычисляем вектор от камеры к лодке.

### СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ - строка 114:

```python
zc = dx * fx + dy * fy + dz * fz
```

**Это и есть скалярное произведение!** `zc = (dx, dy, dz) · (fx, fy, fz)`

**Геометрический смысл:**
- Скалярное произведение вектора на единичный вектор даёт проекцию этого вектора на направление единичного вектора
- `zc` - это координата Z точки в системе координат камеры (глубина)
- Если `zc <= 0`, точка находится сзади камеры → не видна

**Почему скалярное произведение?**
- Чтобы перевести точку из глобальной системы координат в систему камеры, нужно спроецировать вектор на оси базиса камеры
- Проекция = скалярное произведение: `проекция = вектор · единичный_вектор_оси`

### Строки 118-119:

```python
xc = dx * rx + dy * ry + dz * rz
yc = dx * ux + dy * uy + dz * uz
```

**Тоже скалярные произведения!** Проецируем вектор на оси `r` и `u`:
- `xc` - координата X в системе камеры (влево/вправо)
- `yc` - координата Y в системе камеры (вверх/вниз)

### Проверка FOV (строки 121-124):

```python
if abs(xc) > zc + 1e-12:
    return False
if abs(yc) > zc + 1e-12:
    return False
```

**Геометрический смысл:** FOV 90° означает, что полуугол обзора = 45°
- В системе координат камеры: `|xc| ≤ zc` и `|yc| ≤ zc`
- Это эквивалентно условию: `tan(угол) = |xc|/zc ≤ 1`, т.е. угол ≤ 45°

---

## 5. Проверка заслонения горой (строки 128-255)

### Функция `mountain_blocks_boat_at`

**Задача:** Проверить, пересекает ли луч от камеры к лодке конус горы.

### 5.1. Быстрый XY-фильтр (строки 141-166)

**Идея:** Если проекция луча на плоскость XY не попадает в круг основания горы, то луч точно не пересекает конус.

```python
vx = dx
vy = dy
wx = xm - Cx
wy = ym - Cy
v2 = vx*vx + vy*vy
t_proj = (vx*wx + vy*wy) / v2
```

**Строка 153 - снова скалярное произведение!**

`t_proj = (vx*wx + vy*wy) / v2` - это проекция вектора `w` (от камеры к центру горы) на вектор `v` (направление луча в плоскости XY).

**Геометрический смысл:**
- Находим параметр `t`, при котором точка на луче ближе всего к центру горы
- Если `t ∈ [0, 1]`, проверяем расстояние от этой точки до центра
- Если расстояние > `rm`, луч не пересекает основание конуса → не заслоняет

### 5.2. Проверка по высоте (строки 168-202)

**Идея:** Находим интервал параметра `t`, при котором луч проходит через диапазон высот горы [0, hm].

```python
t_zero = -zC / dz  # когда z(t) = 0
t_hm = (hm - zC) / dz  # когда z(t) = hm
```

**Геометрический смысл:**
- Луч: `z(t) = Cz + dz * t`
- Нужно: `0 ≤ z(t) ≤ hm`
- Решаем неравенства и находим `t_z_min` и `t_z_max`

### 5.3. Радиусное неравенство (строки 209-255)

**Идея:** Проверяем, пересекает ли луч конус на интервале [t0, t1].

**Уравнение конуса:**
- В точке на высоте `z`: радиус `r(z) = rm * (1 - z/hm)`
- Условие попадания в конус: `(X - xm)² + (Y - ym)² ≤ r(z)²`

**Параметризация луча:**
- `X(t) = Cx + dx*t - xm = ex + dx*t`
- `Y(t) = Cy + dy*t - ym = ey + dy*t`
- `Z(t) = Cz + dz*t`

**Подставляем в неравенство:**
```
(ex + dx*t)² + (ey + dy*t)² ≤ rm² * (1 - Z(t)/hm)²
```

**Раскрываем скобки и получаем квадратичное неравенство:**
```
g(t) = A*t² + B*t + C ≤ 0
```

**Где:**
- `A1 = dx² + dy²` - для части `X² + Y²`
- `B1 = 2*(ex*dx + ey*dy)` - **скалярное произведение!** `2 * (ex, ey) · (dx, dy)`
- `C1 = ex² + ey²` - квадрат расстояния от камеры до центра горы в XY

- `A2 = alpha * dz²` - для части радиуса конуса
- `B2 = -2*alpha*q0*dz`
- `C2 = alpha*q0²`

**Итоговые коэффициенты:**
```python
A = A1 - A2
B = B1 - B2
C = C1 - C2
```

**Проверка (строки 232-255):**
- Если `A ≈ 0` (линейный случай), проверяем концы интервала
- Иначе находим вершину параболы `t_vertex = -B/(2*A)`
- Проверяем минимум `g(t)` на интервале [t0, t1]
- Если минимум ≤ 0, луч пересекает конус → гора заслоняет лодку

---

## 6. Параметризация движения камеры (строки 258-300)

```python
ABx = xB_end - xA
ABy = yB_end - yA
ABz = zB_end - zA
AB_len = math.sqrt(ABx*ABx + ABy*ABy + ABz*ABz)
T_total = AB_len / v
```

**Что делаем:** Вычисляем вектор AB и полное время движения.

```python
def camera_pos_s(s):
    return (xA + ABx * s,
            yA + ABy * s,
            zA + ABz * s)
```

**Параметризация:** `s ∈ [0, 1]` - доля пройденного пути
- `s = 0` → камера в точке A
- `s = 1` → камера в точке B
- `t = s * T_total` - реальное время

---

## 7. Функция видимости для параметра s (строки 302-319)

```python
def visible_at_s(s):
    Cx, Cy, Cz = camera_pos_s(s)
    visible = []
    for i, boat in enumerate(boats, start=1):
        if not in_camera_fov_at(Cx, Cy, Cz, xb, yb, hb):
            continue
        blocked = False
        for pm in pre_mountains:
            if mountain_blocks_boat_at(Cx, Cy, Cz, boat, pm):
                blocked = True
                break
        if not blocked:
            visible.append(i)
    return len(visible), visible
```

**Что делаем:** Для заданного `s` (позиции камеры):
1. Вычисляем позицию камеры
2. Для каждой лодки:
   - Проверяем попадание в кадр
   - Проверяем, не закрыта ли горами
   - Если видна, добавляем в список

---

## 8. Адаптивный поиск оптимального момента (строки 321-388)

**Проблема:** Нужно найти `s ∈ [0, 1]`, при котором видно максимальное количество лодок, и при равенстве - минимальный `s`.

**Почему не бинарный поиск?** Функция `visible_at_s(s)` не монотонна - количество видимых лодок может меняться непредсказуемо.

**Решение:** Адаптивный DFS с делением отрезка пополам.

### 8.1. Кеширование (строки 332-345)

```python
cache = {}
def get_visible_cached(s):
    if s in cache:
        return cache[s]
    cnt, lst = visible_at_s(s)
    cache[s] = (cnt, lst)
    return cnt, lst
```

**Зачем:** Избегаем повторных вычислений для одного и того же `s`.

### 8.2. Обновление лучшего результата (строки 347-352)

```python
def update_best(s, cnt, lst):
    if cnt > best_cnt or (cnt == best_cnt and s < best_s):
        best_cnt = cnt
        best_s = s
        best_list = lst
```

**Логика:** Обновляем, если:
- Больше видимых лодок, ИЛИ
- Столько же, но `s` меньше (раньше по времени)

### 8.3. DFS с делением отрезка (строки 354-380)

```python
def dfs(l, fl, flist, r, fr, frist, depth):
    # l, r - границы отрезка
    # fl, fr - количество видимых на границах
    # flist, frist - списки видимых лодок
    
    if depth >= MAX_DEPTH or EVALS >= MAX_EVALS:
        return  # ограничение глубины/вычислений
    
    m = 0.5 * (l + r)  # середина
    fm, fmlist = get_visible_cached(m)
    update_best(m, fm, fmlist)
    
    # Рекурсивно обрабатываем левую и правую половины
    dfs(l, fl, flist, m, fm, fmlist, depth + 1)
    dfs(m, fm, fmlist, r, fr, frist, depth + 1)
```

**Оптимизация (строки 362-367):**
```python
local_max = fl if fl > fr else fr
if local_max < best_cnt:
    return  # на этом отрезке не улучшим
```

**Идея:** Если максимум на концах отрезка уже меньше текущего лучшего результата, дальше делить не имеет смысла.

---

## 9. Вывод результата (строки 390-396)

```python
t_ans = best_s * T_total
print(f"{t_ans:.5f}")
print(len(best_list))
for idx in best_list:
    print(idx)
```

Переводим `s` в реальное время и выводим результат.

---

## Итог: Где используются скалярные произведения?

1. **Строка 114:** `zc = dx*fx + dy*fy + dz*fz` - проекция на ось "вперёд" камеры
2. **Строка 118:** `xc = dx*rx + dy*ry + dz*rz` - проекция на ось "вправо"
3. **Строка 119:** `yc = dx*ux + dy*uy + dz*uz` - проекция на ось "вверх"
4. **Строка 153:** `t_proj = (vx*wx + vy*wy) / v2` - проекция для поиска ближайшей точки к центру горы
5. **Строка 217:** `B1 = 2.0 * (ex*dx + ey*dy)` - скалярное произведение в коэффициенте квадратичного неравенства

**Все эти операции - это проекции векторов на другие векторы, что и есть скалярное произведение!**

